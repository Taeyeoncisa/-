

#### ä¸€.å †çš„åŸºæœ¬ä»‹ç»

##### 1ï¼‰ä¸ºä»€ä¹ˆæˆ‘ä»¬éœ€è¦å †

æ•°æ®ç»“æ„çš„é€‰æ‹©ä¸ç®—æ³•å®ç°æ¯æ¯ç›¸å…³ï¼Œæ¯”å¦‚è¦æŒ‰å‡åºè¾“å‡ºä¸€ç³»åˆ—æ•°å€¼ï¼Œåˆ©ç”¨æ•°ç»„å®ç°æˆ–åˆ©ç”¨äºŒå‰æœç´¢æ ‘å®ç°å…¶å¤æ‚åº¦å’Œç®—æ³•å®ç°å®Œå…¨ä¸åŒï¼Œæ•°æ®ç»“æ„ä¹Ÿç›´æ¥å½±å“ç€ç®—æ³•å¤æ‚åº¦ã€‚

åœ¨æ“ä½œç³»ç»Ÿçš„CPUè°ƒåº¦ä¸­ï¼Œç»å¸¸æ¶‰åŠåœ¨å°±ç»ªé˜Ÿåˆ—ä¸­å¢åŠ ä¸€ä¸ªä½œä¸šï¼Œä»¥åŠä»å°±ç»ªé˜Ÿåˆ—ä¸­é€‰æ‹©ä¸€ä¸ªä½œä¸šå ç”¨CPUï¼›ä¹‹å‰åœ¨æŸä¸ªæ±‰æœä½“éªŒé¦†ï¼Œä¸€ç›´æœ‰æ–°å®¢æˆ·åˆ°æ¥ï¼Œå•†å®¶ä¼šæ ¹æ®ä¼šå‘˜ç­‰çº§é€‰æ‹©æŒ‘é€‰æ±‰æœçš„å®¢æˆ·ã€‚ç”±æ­¤å¯è§ï¼Œä¸ç®¡æ˜¯ç”Ÿæ´»ä¸­è¿˜æ˜¯è®¡ç®—æœºç³»ç»Ÿçš„å®ç°éƒ½ç¦»ä¸å¼€ä¸¤ä¸ªé‡è¦çš„æ“ä½œï¼š**æ’å…¥**,  **æ‰¾å‡ºæœ€å¤§å€¼**ï¼ˆä¹Ÿå¯ä»¥ç†è§£ä¸ºæƒé‡æœ€é«˜ï¼ŒæŒ‰å€¼æ’åºå…¶å®å°±æ˜¯å°†å€¼ä½œä¸ºæƒé‡ï¼‰

å…ˆè€ƒè™‘ä¸€ä¸‹æˆ‘ä»¬ä¹‹å‰å¸¸ç”¨çš„æ•°æ®ç»“æ„ï¼Œåœ¨çº¿æ€§è¡¨ä¸­ï¼ŒæŸ¥æ‰¾æœ€å¤§å…ƒç´ è¦éå†æ•´ä¸ªè¡¨ï¼Œåœ¨æ’å¥½åºçš„çº¿æ€§è¡¨ä¸­ï¼Œä¸ºä¿è¯æ’å…¥å…ƒç´ ä¸ç ´åçº¿æ€§è¡¨çš„å±æ€§ï¼Œéœ€è¦éå†è¡¨ä½¿å…ƒç´ æ’å…¥åˆ°åˆé€‚çš„ä½ç½®ï¼Œä¼˜å…ˆé˜Ÿåˆ—å¯ä»¥å…¼é¡¾åˆ°æ’å…¥å’Œæ‰¾æœ€å€¼ï¼Œå †å°±æ˜¯ä¸€ç§ä¼˜å…ˆé˜Ÿåˆ—ï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬ä¼šä»‹ç»åœ¨å †ä¸Šè¿™äº›æ“ä½œçš„ç®—æ³•å¤æ‚åº¦ã€‚

##### 2ï¼‰ä»€ä¹ˆæ˜¯å †

- å †æ˜¯ä¸€ä¸ª**å®Œå…¨äºŒå‰æ ‘**ï¼Œå¹¶ä¸”æ»¡è¶³å †çš„æ€§è´¨

- å †çš„æ€§è´¨ï¼š
  - æ¯ä¸€ä¸ªçˆ¶èŠ‚ç‚¹çš„keyéƒ½å¤§äºç­‰äºå­èŠ‚ç‚¹çš„keyï¼ˆå¤§æ ¹å †ï¼‰
  - æˆ–è€…ï¼šæ¯ä¸€ä¸ªçˆ¶èŠ‚ç‚¹çš„keyéƒ½å°äºç­‰äºå­èŠ‚ç‚¹çš„keyï¼ˆå°æ ¹å †ï¼‰
  - é€’å½’å®šä¹‰ï¼šé€’å½’çš„æ€æƒ³å¯¹äºæ ‘éå¸¸é‡è¦
    - çˆ¶èŠ‚ç‚¹çš„keyå¤§äºç­‰äºå­èŠ‚ç‚¹çš„keyï¼Œå¹¶ä¸”ä»¥å­èŠ‚ç‚¹ä¸ºæ ¹èŠ‚ç‚¹çš„æ ‘ä¹Ÿæ˜¯å¤§æ ¹å †ã€‚

ä»¥ä¸‹è®¨è®ºä»¥å¤§æ ¹å †ä¸ºä¾‹ã€‚

##### 3ï¼‰å †çš„è¡¨ç¤º

æ ¹æ®å®Œå…¨äºŒå‰æ ‘çš„æ€§è´¨ï¼ŒTçš„æ ¹èŠ‚ç‚¹å­˜å‚¨åœ¨H[1]ä¸­ã€‚
å‡è®¾Tçš„èŠ‚ç‚¹xå­˜å‚¨åœ¨H[j]ä¸­ï¼Œå¦‚æœå®ƒæœ‰å·¦å­èŠ‚ç‚¹ï¼Œè¿™ä¸ªå­èŠ‚ç‚¹å­˜å‚¨åœ¨H[2j]ä¸­ï¼›å¦‚æœå®ƒä¹Ÿæœ‰å³å­èŠ‚ç‚¹ï¼Œè¿™ä¸ªå­èŠ‚ç‚¹å­˜å‚¨åœ¨ H[2j+1]ä¸­
å…ƒç´ H[j]çš„çˆ¶èŠ‚ç‚¹å­˜å‚¨åœ¨H[j/2]ï¼ˆä¸‹å–æ•´ï¼‰ä¸­

##### 4ï¼‰å †çš„ç‰¹æ€§

æ²¿ç€æ¯æ¡ä»æ ¹åˆ°å¶å­çš„è·¯å¾„ï¼Œå…ƒç´ çš„é”®å€¼ä»¥éå‡åºæ’åˆ—ã€‚

##### 5ï¼‰è¿ç®—

å †çš„åŸºæœ¬è¿ç®—å®ç°æ€æƒ³æ˜¯è§£å†³ä¸å †æœ‰å…³ç®—æ³•é¢˜çš„å…³é”®

åœ¨æ¯ç§åŸºæœ¬æ“ä½œåé™„å¸¦äº†åŸºäºc++STLçš„å®ç°

â‘ ä¸¤ä¸ªåŸºæœ¬æ“ä½œ

è¿™ä¸¤ä¸ªåŸºæœ¬æ“ä½œæ˜¯å †çš„è¿ç®—å®ç°çš„åŸºç¡€

ğŸ˜ˆsift-up

å‡å®šå¯¹äºæŸä¸ªi>1, H[i]å˜æˆäº†é”®å€¼å¤§äºå®ƒçˆ¶èŠ‚ç‚¹é”®å€¼çš„å…ƒç´ ï¼Œè¿™æ ·å°±è¿åäº†å †çš„ç‰¹æ€§ï¼Œå› æ­¤è¿™ç§æ•°æ®ç»“æ„å°±ä¸å†æ˜¯å †äº†ã€‚å¦‚è¦ä¿®å¤å †çš„ç‰¹æ€§ï¼Œéœ€è¦ç”¨ç§°ä¸ºSift-upçš„è¿ç®—æŠŠæ–°çš„æ•°æ®é¡¹ä¸Šç§»åˆ°åœ¨äºŒå‰æ ‘ä¸­é€‚åˆå®ƒçš„ä½ç½®ä¸Šï¼Œè¿™æ ·å †çš„å±æ€§å°±ä¿®å¤äº†ã€‚
sift-up è¿ç®—æ²¿ç€ä»H[i]åˆ°æ ¹èŠ‚ç‚¹çš„æƒŸä¸€ä¸€æ¡è·¯å¾„ï¼ŒæŠŠH[i]ç§»åˆ°é€‚åˆå®ƒçš„ä½ç½®ä¸Šã€‚    åœ¨æ²¿ç€è·¯å¾„çš„æ¯ä¸€æ­¥ä¸Šï¼Œéƒ½å°†H[i]é”®å€¼å’Œå®ƒçˆ¶èŠ‚ç‚¹çš„é”®å€¼H[i/2]ç›¸æ¯”è¾ƒã€‚

```cpp
void siftup(vector<int> &heap,int i){
    if(i==1) return;
    while(i>1&&heap[i]>=heap[i/2]){
        swap(heap[i], heap[i/2]);
        i = i/2;
    }
}
```

ğŸ˜ˆsift-down

 å‡å®šå¯¹äºi<=n/2,ï¼Œå­˜å‚¨åœ¨H[i]ä¸­å…ƒç´ çš„é”®å€¼å˜æˆå°äºH[2i]å’ŒH[2i+1]ä¸­çš„æœ€å¤§å€¼(å¦‚æœH[2i+1]å­˜åœ¨çš„è¯)ï¼Œè¿™æ ·å°±è¿åäº†å †çš„ç‰¹æ€§ï¼Œæ ‘å°±ä¸å†è¡¨ç¤ºä¸€ä¸ªå †ã€‚
å¦‚è¦ä¿®å¤å †çš„ç‰¹æ€§ï¼Œéœ€è¦ç”¨Sift-downè¿ç®—ä½¿H[i]â€œæ¸—â€åˆ°äºŒå‰æ ‘ä¸­é€‚åˆå®ƒçš„ä½ç½®ä¸Šï¼Œæ²¿ç€è¿™æ¡è·¯å¾„çš„æ¯ä¸€æ­¥ï¼Œéƒ½æŠŠH[i]çš„é”®å€¼å’Œå­˜å‚¨åœ¨å®ƒå­èŠ‚ç‚¹(å¦‚æœå­˜åœ¨)ä¸­çš„ä¸¤ä¸ªé”®å€¼é‡Œæœ€å¤§çš„é‚£ä¸ªç›¸æ¯”è¾ƒ

```cpp
void siftdown(vector<int> &heap,int i){
    unsigned int n = unsigned(heap.size()-1);
    int maxindex;
    while(2*i<=n){
        if(2*i==n) maxindex = 2*i;
        else maxindex = heap[2*i]>heap[2*i+1]?2*i:2*i+1;
        
        if(heap[maxindex]>=heap[i]) {
            swap(heap[maxindex],heap[i]);
            i = maxindex;
        }
        else return;
    }
}
```

â‘¡æ’å…¥

æ’å…¥æ“ä½œåŸºäºsift-upæ“ä½œï¼Œå¯ä»¥å…ˆå°†å…ƒç´ æ’å…¥åˆ°å †çš„å°¾éƒ¨ï¼Œç„¶åè¿›è¡Œä¸Šç§»æ“ä½œè¿›è¡Œè°ƒæ•´ã€‚

```cpp
void insertHeap(vector<int> &heap,int a){
    heap.push_back(a);
    siftup(heap,int(heap.size())-1);
}
// STL
vector.push_back(11);
push_heap(vector.begin()+1,vector.end());
```

**æ—¶é—´å¤æ‚åº¦**=O(logn)

â‘¢åˆ é™¤

åˆ é™¤æ“ä½œæ˜¯åŸºäºsift-upçš„sift-downæ“ä½œï¼Œå…ˆå°†å¾…åˆ é™¤çš„å…ƒç´ iå’Œæœ€åä¸€ä¸ªå…ƒç´ nè¿›è¡Œäº’æ¢ï¼Œåˆ é™¤æœ€åä¸€ä¸ªå…ƒç´ nï¼Œç„¶åå¯¹iä½ç½®çš„å…ƒç´ è¿›è¡Œsift-upæˆ–sift-downæ“ä½œ

```cpp
void deleteHeap(vector<int> &heap,int i){
    swap(heap[i],heap[heap.size()-1]);
    heap.pop_back();
    if(i!=1&&heap[i]>=heap[i/2]) siftup(heap, i);
    else siftdown(heap, i);
}
```

**æ—¶é—´å¤æ‚åº¦**=O(logn)

â‘£åˆ é™¤æœ€å¤§å…ƒç´ 

åˆ é™¤æœ€å¤§å…ƒç´ ç›¸å½“äºè°ƒç”¨`deleteHeap(heap,1)`

```cpp
void deleteHeapMax(vector<int> &heap){
    deleteHeap(heap,1);
}
// STL
pop_heap(vector.begin()+1,vector.end());
vector.pop_back();
// å°†æœ€å¤§å…ƒç´ ç§»åˆ°æœ«å°¾ï¼Œéœ€è¦è‡ªè¡Œåˆ é™¤
```

**æ—¶é—´å¤æ‚åº¦**=O(logn)

â‘¤åˆ›å»ºå †

åˆ›å»ºå †çš„æ€æƒ³åŒæ ·åŸºäºsift-upå’Œsift-downä¸¤ä¸ªåŸºæœ¬æ“ä½œ

é—®é¢˜æè¿°ï¼šç»™å®šä¸€ä¸ªæ•°ç»„ï¼Œæ„é€ ä¸€ä¸ªå †

ğŸ˜ˆæ€æƒ³ä¸€ï¼šä»ä¸€ä¸ªç©ºå †å¼€å§‹ï¼Œä¸æ–­æ’å…¥æ•°ç»„ä¸­çš„å…ƒç´ 

```cpp
vector<int> makeHeap1(int a[],int n){
    vector<int> heap;
    heap.push_back(0);  // ä¹Ÿå¯ä»¥ä¸å ç”¨heap[0]çš„ä½ç½®ï¼Œä½†æ˜¯è¿™æ ·ä¾¿äºè§’æ ‡è®¡ç®—
    for(int i=0;i<n;i++){
        insertHeap(heap, a[i]);
    }
    return heap;
}
```

â€‹	â“è¿™é‡Œæœ‰ä¸€ä¸ªç–‘é—®ï¼šè¿™ç§æ„é€ æ–¹æ³•çš„æ—¶é—´å¤æ‚åº¦æ˜¯å¤šå°‘ï¼Ÿ

â€‹			æœ€å¼€å§‹æˆ‘çš„æƒ³æ³•æ˜¯å¯¹äºç¬¬kä¸ªå…ƒç´ ï¼Œæ’å…¥æ“ä½œçš„æ—¶é—´å¤æ‚åº¦æ˜¯`O(logk)`ï¼Œé‚£æ±‚å’Œåä¸º
$$
O(log(\frac{n(n+1)}{2}))=O(logn+log(n+1)-log2)
$$
â€‹			é‚£æ—¶é—´å¤æ‚åº¦ä¸å°±æ˜¯O(logn)å—ï¼Ÿè¿™é‡ŒçŠ¯äº†ä¸€ä¸ªé”™è¯¯ï¼Œå°±æ˜¯log(n+1)ä¸èƒ½å½’äºlog(n)ï¼Œæ­£ç¡®åšæ³•åº”è¯¥å¯¹ä¸Šè¿°å’Œå¼æ±‚ä¸Šç•Œå’Œä¸‹ç•Œã€‚å¯¹äºlogkæ±‚å’Œçš„æ¨å¯¼å¦‚ä¸‹ï¼š
$$
\begin{equation}
\begin{split}
1.\sum_{k=1}^{n}logk &=logn+\sum_{k=1}^{n-1}logk \\
&<=logn+\int_{1}^{n}logxdx \\
&=logn+nlogn-nloge+loge \\
\\
2.\sum_{k=1}^{n}logk &= \sum_{k=2}^{n}logk \\
&>=\int_{1}^{n}logxdx \\
&= nlogn-nloge+loge
\end{split}
\end{equation}
$$
â€‹			ç»¼ä¸Šï¼Œæ—¶é—´å¤æ‚åº¦ä¸ºO(nlogn).

ğŸ˜ˆå°†æ•°ç»„çœ‹åšä¸€ä¸ªæœªè°ƒæ•´å¥½çš„å †

è¿™é‡Œç”¨åˆ°äº†æ ‘çš„é€’å½’æ€æƒ³ï¼Œå¦‚æœä¸€ä¸ªç»“ç‚¹çš„å·¦å­æ ‘å’Œå³å­æ ‘éƒ½æ˜¯å †ï¼Œé‚£ä¹ˆåªéœ€è¦å¯¹è¯¥èŠ‚ç‚¹è¿›è¡Œsift-downè°ƒæ•´å³å¯å¾—åˆ°å †ã€‚

nä¸ºæœ€åä¸€ä¸ªç»“ç‚¹ï¼Œé‚£ä¹ˆn/2ä¸ºæœ€åä¸€ä¸ªæœ‰å­©å­çš„çˆ¶èŠ‚ç‚¹ï¼Œåœ¨`n/2+1`è‡³`n`ä¹‹é—´çš„ç»“ç‚¹å°±éƒ½æ˜¯å¶å­ç»“ç‚¹ï¼Œæ¯ä¸ªå¶å­ç»“ç‚¹å¯ä»¥çœ‹ä½œæ˜¯ä¸€ä¸ªå †ï¼Œä»ç»“ç‚¹`n/2`å¼€å§‹ï¼Œå…¶å·¦å­æ ‘å’Œå³å­æ ‘éƒ½æ˜¯å †ï¼Œå°†è¯¥ç»“ç‚¹çœ‹åšä¸€ä¸ªæ ¹èŠ‚ç‚¹ï¼Œè¿›è¡Œsift-downæ“ä½œï¼Œä¾æ¬¡å¯¹`n/2-1` ,`n/2-2`ç»“ç‚¹è¿›è¡Œè°ƒæ•´ï¼Œå³å¯å¾—åˆ°ä¸€ä¸ªå¤§æ ¹å †ã€‚

```cpp
void makeHeap2(vector<int> &heap){
    int n = int(heap.size())-1;
    for(int j=n/2;j>=1;j--){
        siftdown(heap, j);
    }
}
```

â“ç®—æ³•åˆ†æï¼š

â€‹			æ ‘é«˜H=lognï¼Œå¯¹äºç¬¬iå±‚çš„å…ƒç´ ï¼Œç§»åŠ¨æ¬¡æ•°æœ€å¤šä¸ºH-iï¼Œç¬¬iå±‚éœ€è¦ç§»åŠ¨çš„ç‚¹æœ€å¤šæœ‰2^iä¸ªï¼Œç§»åŠ¨æ€»æ¬¡æ•°çš„ä¸Šç•Œä¸º
$$
\begin{equation}
\begin{split}
& \sum_{i=0}^{H-1}(H-i)2^i =\sum_{m=1}^{H}m2^{H-m} =2^H\sum_{m=1}^{H}m2^{-m} <=2n \\
\\
& åœ¨æ¯æ¬¡å¾ªç¯ä¸­æœ€å¤šæœ‰ä¸¤æ¬¡æ¯”è¾ƒï¼Œæ‰€ä»¥å…ƒç´ æ¯”è¾ƒæ¬¡æ•°ä¸Šç•Œä¸º4n \\
\\ 
& å½“æ•°ç»„æœ¬èº«å°±æ˜¯å¤§æ ¹å †æ—¶ï¼Œè¿›å…¥sift-downå‡½æ•°è¿›è¡Œä¸¤æ¬¡æ¯”è¾ƒï¼ˆè‡³å°‘ä¸€æ¬¡å¾ªç¯ï¼‰ï¼Œ
\\ 
&æœ€å°æ¯”è¾ƒæ¬¡æ•°ä¸º2*n/2=n \\

\end{split}
\end{equation}
$$
â€‹			æ—¶é—´å¤æ‚åº¦O(n),ç©ºé—´å¤æ‚åº¦O(1)

ğŸ˜ˆSTL(åŒ…å«å¤´æ–‡ä»¶algorithm)

```cpp
make_heap(vector.begin()+1,vector.end());  // å¤§æ ¹å †
make_heap(heap.begin()+1, heap.end(), greater<>());  // å°æ ¹å †
```

è¿™é‡Œçš„vector[0]æ˜¯æ— ç”¨çš„ç©ºé—´ï¼Œä½¿ç”¨+1æ˜¯ä¾¿äºè§’æ ‡è®¡ç®—

å‡½æ•°åŸå‹

```cpp
make_heap(<#_RandomAccessIterator __first#>, <#_RandomAccessIterator __last#>, <#_Compare __comp#>)
```

cmpé»˜è®¤ä¸º`>`

â‘¥å †æ’åº

å…ˆå°†å¾…æ’åºæ•°ç»„å˜æˆå †ï¼Œç„¶åå¯¹æœ€å¤§å€¼å…ƒç´ ä¸æœ€åä¸€ä¸ªå…ƒç´ äº’æ¢å¹¶è¿›è¡Œsift-downæ“ä½œ

```cpp
// STL
sort_heap(vector.begin()+1,vector.end());
```

æ³¨æ„ï¼šä½¿ç”¨ç›¸å…³å‡½æ•°æ—¶ç¬¬ä¸‰ä¸ªå‚æ•°è¦ä¿æŒä¸€è‡´

#### äºŒ.ä¹ é¢˜

##### 1.æ•°ç»„ä¸­ç¬¬kä¸ªæœ€å¤§å…ƒç´ 

https://leetcode-cn.com/problems/kth-largest-element-in-an-array/

- æ€è·¯ä¸€ï¼šæ’åº

  - å¿«æ’ï¼šä»å¤§åˆ°å°æ’åºï¼Œå½“é‡åˆ°å¯¹åº”ä¸‹æ ‡ä¸ºk-1çš„å…ƒç´ æ—¶åœæ­¢é€’å½’

  ```cpp
  class Solution {
  public:
      bool flag=true;
      int value;
      int index;
      int findKthLargest(vector<int>& nums, int k) {
         // å¿«é€Ÿæ’åº
         index=k;
          quickSort(nums,0,nums.size()-1);
          return value;
      }
      void quickSort(vector<int> &nums,int begin,int end){
          if(flag&&begin<=end){
              int temp=nums[begin];
              int i=begin;
              int j=end;
              while(i<j){
                  while(nums[j]<=temp&&j>i) j--;
                  nums[i]=nums[j];
                  while(nums[i]>temp&&i<j) i++;
                  nums[j]=nums[i];
              }
              nums[j] = temp;
              if(j==index-1){
                  flag=false;
                  value=nums[j];
                  return;
              }
              quickSort(nums,begin,j-1);
              quickSort(nums,j+1,end);
          }
      }
  };
  ```

  

  <img src="/Users/anita/Library/Application Support/typora-user-images/image-20211104212729363.png" width='500px'>

  

  çœ‹äº†ä¸‹é¢˜è§£ï¼Œå¯ä»¥å†ä¼˜åŒ–ä¸€ä¸‹ï¼Œæ’åˆ°çš„ä½ç½®ä¸kæ¯”è¾ƒï¼Œæ¯”kå¤§çš„è¯å°±åªå¯¹å·¦è¾¹éƒ¨åˆ†é€’å½’ï¼Œæ¯”kå°çš„è¯å°±åªå¯¹å³è¾¹éƒ¨åˆ†é€’å½’

  - å †æ’åºï¼šå½“ç§»åŠ¨åˆ°ç¬¬ké¡¹æ—¶åœæ­¢æ’åºï¼Œæ€æƒ³å’Œé€‰æ‹©æ’åºæœ‰ç‚¹ç›¸è¿‘ï¼Œä½†æ˜¯æ—¶é—´å¤æ‚åº¦æ›´ä½

```cpp
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        // åˆ›å»ºå¤§æ ¹å †
        make_heap(nums.begin(),nums.end());
        // æ‰§è¡Œk-1æ¬¡ä¸‹ç§»æ“ä½œ
        for(int i=0;i<k-1;i++){
            pop_heap(nums.begin(),nums.end()-i);
        }
        return nums[0];
    }
};
```



<img src="/Users/anita/Library/Application Support/typora-user-images/image-20211104174102082.png" width='500px'>



##### 2.åˆå¹¶kä¸ªå‡åºé“¾è¡¨

https://leetcode-cn.com/problems/merge-k-sorted-lists/

åŸºæœ¬æ€è·¯ï¼šå½’å¹¶æ’åºçš„æ€æƒ³ï¼Œä½†ç”±äºæ˜¯é“¾è¡¨ï¼Œæ— éœ€ç»™æ ¼å¤–çš„ç©ºé—´ã€‚å°†ç»“ç‚¹éƒ½æ’å…¥ç¬¬ä¸€ä¸ªå…ƒç´ æœ€å°çš„é“¾è¡¨ï¼Œç»™è¯¥é“¾è¡¨å»ºç«‹ä¸€ä¸ªéå†çš„æŒ‡é’ˆï¼Œæ¯æ¬¡å°†æœ€å°çš„æ•°å€¼æ’å…¥è¯¥æŒ‡é’ˆä¹‹åçš„ä½ç½®ï¼Œæ•°ç»„å­˜æ”¾å…¶ä½™é“¾è¡¨ä¸‹ä¸€ä¸ªå¾…æ¯”è¾ƒçš„ç»“ç‚¹ã€‚ï¼ˆå› ä¸ºé™¤äº†è¦è¾“å…¥çš„é“¾è¡¨ï¼Œå…¶ä½™é“¾è¡¨æ˜¯å¦ä¿ç•™åŸçŠ¶æ— æ„ä¹‰ï¼‰

è¿›ä¸€æ­¥æ€è€ƒï¼šåœ¨æ‰¾nä¸ªå…ƒç´ çš„æœ€å°å€¼æ—¶ï¼ŒæŒ‡é’ˆä¼šæŒ‡å‘æ‰¾åˆ°çš„æœ€å°å€¼ï¼Œç„¶åè¯¥æœ€å°å€¼æ‰€åœ¨é“¾è¡¨çš„éå†æŒ‡é’ˆå‘åç§»1ï¼Œå…¶å®ä¸éœ€è¦å…¨éƒ¨é‡æ–°æ¯”è¾ƒï¼Œåªéœ€è¦æ¯”è¾ƒè¿™ä¸ªæ–°å…ƒç´ å’Œå…¶ä½™n-1ä¸ªå…ƒç´ çš„å¤§å°å³å¯ï¼Œè¿™æ ·å¯ä»¥é¿å…ä¸€ç›´éå†æ•´ä¸ªåºåˆ—ï¼Œè¿™å°±è®©æˆ‘ä»¬æƒ³åˆ°äº†å †ï¼Œéœ€è¦æ‰¾æœ€å°å€¼ï¼Œå¹¶ä¸”ä¼šæŒç»­ç»™æ’åºå¥½çš„åºåˆ—æ’å…¥å°‘é‡æ–°å…ƒç´ ã€‚

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
 struct Node{
     int val;
     int index;
 };
bool cmp(Node a,Node b){
        return a.val>b.val;
}
class Solution {
public:
    // bool cmp(Node a,Node b){
    //     return a.val<b.val;
    // }
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        vector<Node> heap;
        ListNode* ptr=nullptr;
        ListNode* temp=nullptr;
        int minIndex;
        for(int i=0;i<lists.size();i++){
            if(lists[i]!=nullptr){
                Node temp={lists[i]->val,i};
                heap.push_back(temp);
            }
        }
        if(heap.size()==0) return nullptr;
        // å»ºç«‹å°æ ¹å †
        make_heap(heap.begin(),heap.end(),cmp);
        // 1-å…ˆç¡®å®šå¾…æ’å…¥çš„é“¾è¡¨
        ptr=lists[heap[0].index];
        minIndex=heap[0].index;
        // 2-åˆ é™¤å…ƒç´ 
        pop_heap(heap.begin(),heap.end(),cmp);
        heap.pop_back();
        if(ptr->next!=nullptr){
            Node temp={ptr->next->val,minIndex};
            heap.push_back(temp);
            push_heap(heap.begin(),heap.end(),cmp);
        }
        while(heap.size()!=0){
            int tempindex=heap[0].index;
            if(tempindex==minIndex){
                temp=ptr->next;
            }else{
                temp=lists[tempindex];
                lists[tempindex]=temp->next;
                temp->next=ptr->next;
                ptr->next=temp;
            }
            if(ptr->next!=nullptr) ptr=ptr->next;
            pop_heap(heap.begin(),heap.end(),cmp);
            heap.pop_back();
            if(tempindex!=minIndex&&lists[tempindex]!=nullptr){
                Node temp={lists[tempindex]->val,tempindex};
                heap.push_back(temp);
                push_heap(heap.begin(),heap.end(),cmp);
            }else if(tempindex==minIndex&&ptr->next!=nullptr){
                Node temp={ptr->next->val,minIndex};
                heap.push_back(temp);
                push_heap(heap.begin(),heap.end(),cmp);
            }
        }
        return lists[minIndex];
    }
};
```

æ€è·¯æ²¡é”™ï¼Œä»£ç ä¸å¤ªä¼˜ç¾ï¼Œå¾—è€ƒè™‘å¾ˆå¤šç‰¹æ®Šæƒ…å†µ



<img src="/Users/anita/Library/Application Support/typora-user-images/image-20211104232150788.png" width='500px'>



##### 3.æ»‘åŠ¨çª—å£æœ€å¤§å€¼é—®é¢˜

https://leetcode-cn.com/problems/sliding-window-maximum/

æ€è·¯ä¸ä¸Šä¸€é¢˜æ€è·¯å¾ˆæ¥è¿‘ï¼Œæ¯æ¬¡å‡å°‘ä¸€ä¸ªï¼Œå†å¢åŠ ä¸€ä¸ªï¼Œä½¿ç”¨å¤§æ ¹å †å¾ˆå¥½å®ç°ï¼Œæ¯æ¬¡ç§»åŠ¨æ—¶å°†æœ€å¤§çš„å…ƒç´ ä¿å­˜ã€‚

å¢åŠ çš„æ—¶å€™å¾ˆå¥½å¢åŠ ï¼Œä½†æ˜¯åˆ é™¤çš„æ—¶å€™æ¯”è¾ƒå›°éš¾ï¼Œå¯ä»¥å…ˆä¸åˆ é™¤ï¼Œå¦‚æœæœ€å¤§å€¼ä¸åœ¨æ»‘åŠ¨çª—å£èŒƒå›´å†…ï¼Œå°±åˆ é™¤æœ€å¤§å€¼ï¼Œç›´åˆ°æœ€å¤§å€¼åœ¨æ»‘åŠ¨çª—å£èŒƒå›´å†…ã€‚

```cpp
struct Node{
    int val;
    int index;
};
bool cmp(Node a,Node b){
        return a.val<b.val;
}
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        vector<int> ans;
        vector<Node> heap;
        for(int i=0;i<k;i++){
            Node temp={nums[i],i};
            heap.push_back(temp);
        }
        make_heap(heap.begin(),heap.end(),cmp);
        ans.push_back(heap[0].val);
        for(int i=k;i<nums.size();i++){
            Node temp={nums[i],i};
            heap.push_back(temp);
            push_heap(heap.begin(),heap.end(),cmp);
            while(heap[0].index<i-k+1){
                pop_heap(heap.begin(),heap.end(),cmp);
                heap.pop_back();
            }
            ans.push_back(heap[0].val);
        }
        return ans;
    }
};
```

##### 4.æ•°æ®æµä¸­ç¬¬Kå¤§å…ƒç´ 

https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/

æ€è·¯å’Œ1.ä¸€è‡´ï¼Œè¿™é‡Œå°±å¾ˆæ˜æ˜¾è¦ç”¨å †äº†ï¼ŒåŠ¨æ€æ’å…¥æ–°å…ƒç´ ä»¥åŠæ±‚æœ€å¤§å€¼ã€‚

å¦‚æœæ¯æ¬¡æ’å…¥å…ƒç´ åé‡æ„å †ï¼Œå†ä»¿ç…§ä¹‹å‰çš„æ€è·¯æ±‚ç¬¬kå¤§å…ƒç´ ï¼Œæœ‰äº›æµªè´¹å‰ä¸€æ¬¡å·²ç»åšè¿‡çš„è°ƒæ•´ï¼ŒåŸºäºä¸€ä¸ªç¬¬kå¤§å…ƒç´ å·²ç»åœ¨æ ¹éƒ¨çš„å †ï¼ˆè§1.ï¼‰å…¶å®æ’å…¥çš„å…ƒç´ åªéœ€è¦å’ŒA[n-k+2]å…ƒç´ è¿›è¡Œæ¯”è¾ƒï¼Œå¦‚æœæ¯”A[n-k+2]å°ï¼Œç›´æ¥æ’å…¥åˆ°vector[n-k+2]çš„ä½ç½®ç„¶åè°ƒæ•´å †ï¼Œé‚£ä¸æ˜¯ä¼šè¦†ç›–äº†åŸæ•°æ®å—ï¼Œå¯ä»¥å°†æš‚æ—¶æœ€å¤§çš„å‰k-1ä¸ªå…ƒç´ å•ç‹¬å­˜å‚¨åœ¨ä¸€ä¸ªvectorä¸­ï¼›å¦‚æœæ¯”A[n-k+2]å¤§ï¼Œåˆ™è¯´æ˜è¯¥å…ƒç´ åº”è¯¥å±äºå‰k-1ä¸ªå…ƒç´ çš„vectorä¸­ï¼ŒæŒ¤æ‰è¿™kä¸ªå…ƒç´ ä¸­æœ€å°çš„å€¼ï¼Œå› æ­¤å¯ä»¥å°†å‰k-1ä¸ªå…ƒç´ å»ºç«‹å°æ ¹å †ï¼ˆèµ·å§‹æ—¶è¿™k-1ä¸ªå…ƒç´ æ˜¯å‡åºåºåˆ—ï¼Œæœ¬èº«å°±æ˜¯ä¸€ä¸ªå°æ ¹å †ï¼‰ï¼Œç§»é™¤æ ¹éƒ¨å…ƒç´ ï¼Œç„¶åå°†æ ¹éƒ¨å…ƒç´ æ’å›åŸæ•°ç»„ã€‚(mä»£è¡¨addæ“ä½œæ¬¡æ•°)

æ—¶é—´å¤æ‚åº¦O(n+(k+m)logn+mlogk)

ç©ºé—´å¤æ‚åº¦O(k)

å†™åˆ°è¿™é‡Œçš„æ—¶å€™çªç„¶æƒ³åˆ°ï¼Œå‰©ä¸‹çš„n-kçš„å…ƒç´ å®é™…ä¸Šæ²¡æœ‰å­˜åœ¨çš„æ„ä¹‰äº†ï¼Œç¬¬kå¤§çš„å…ƒç´ åªå¯èƒ½æ˜¯åŸæ•°ç»„æ ¹éƒ¨æˆ–è€…æ–°æ’å…¥çš„å…ƒç´ ï¼Œæ’å…¥å…ƒç´ æ—¶ç›´æ¥å’ŒåŸæ•°ç»„å †æ ¹éƒ¨è¿›è¡Œæ¯”è¾ƒï¼Œå¦‚æœæ¯”å…¶å°ï¼Œç›´æ¥èˆå¼ƒï¼Œè¾“å‡ºæ ¹éƒ¨é”®å€¼ï¼Œå¦‚æœæ¯”å…¶å¤§ï¼Œå†æ’å…¥k-1ä¸ªå…ƒç´ çš„å †ï¼Œå †ä¸­é€€ä¸‹æ¥çš„æœ€å°å€¼ç›´æ¥èµ‹ç»™åŸæ•°ç»„å †çš„æ ¹éƒ¨ï¼Œè¿™æ ·ä¼˜åŒ–æ—¶é—´å¤æ‚åº¦ä¸ºO(n+klogn+mlogk)

```cpp
class KthLargest {
public:
    vector<int> kth;
    vector<int> mynums;
    int myk;
    bool firstInsert=true;
    KthLargest(int k, vector<int>& nums) {
        make_heap(nums.begin(),nums.end());
        // æ‰¾åˆ°ç¬¬kå¤§å…ƒç´ 
        for(int i=0;i<k-1;i++){
            pop_heap(nums.begin(),nums.end()-i);
        }
        for(int i=k-2;i>=0;i--){
            kth.push_back(nums[nums.size()-1-i]);
        }
        mynums=nums;
        myk=k;
    }
    
    int add(int val) {
        if(mynums.size()==0){
            mynums.push_back(val);
        }else if(val>mynums[0]){
            kth.push_back(val);
            push_heap(kth.begin(),kth.end(),greater<>());
            pop_heap(kth.begin(),kth.end(),greater<>());
            mynums[0]=kth[myk-1];
            kth.pop_back();
        }else if(firstInsert&&val<=mynums[0]&&mynums.size()<myk){
            mynums[0]=val;
        }
        firstInsert=false;
        return mynums[0];
    }
};

/**
 * Your KthLargest object will be instantiated and called as such:
 * KthLargest* obj = new KthLargest(k, nums);
 * int param_1 = obj->add(val);
 */
```

ä¼˜åŒ–äº†ä¸€ä¸‹ä»£ç ï¼š(åªç»´æŠ¤kthå †)

```cpp
class KthLargest {
public:
    vector<int> kth;
    int myk;
    KthLargest(int k, vector<int>& nums) {
        make_heap(nums.begin(),nums.end());
        // æ‰¾åˆ°ç¬¬kå¤§å…ƒç´ 
        int i=0;
        while(i<k&&i<nums.size()) {
            pop_heap(nums.begin(),nums.end()-i);
            i++;
        }
        i=k-1;
        while(i>=0){
            if(i>=nums.size()){
                i--;
                continue;
            }
            kth.push_back(nums[nums.size()-1-i]);
            i--;
        } 
        myk=k;
    }
    
    int add(int val) {
        if(kth.size()==myk-1||val>kth[0]){
            kth.push_back(val);
            push_heap(kth.begin(),kth.end(),greater<>());
            if(kth.size()>myk){
                pop_heap(kth.begin(),kth.end(),greater<>());
                kth.pop_back();
            }
        }
        return kth[0];
    }
};

/**
 * Your KthLargest object will be instantiated and called as such:
 * KthLargest* obj = new KthLargest(k, nums);
 * int param_1 = obj->add(val);
 */
```

